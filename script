// enhancements.js (uxuiflow-inspired interaction polish)
// Save/replace as enhancements.js in the same folder as your HTML

(function () {
  // ---------- 1) RIGHT-CLICK + KEY SHORTCUTS ----------
  document.addEventListener('contextmenu', function (e) {
    e.preventDefault(); // block right-click globally (deterrent)
  }, { passive: false });

  document.addEventListener('keydown', function (e) {
    const tag = e.target && e.target.tagName ? e.target.tagName.toLowerCase() : null;
    const editable = e.target && (e.target.isContentEditable || tag === 'input' || tag === 'textarea' || tag === 'select');
    if (editable) return; // allow typing naturally

    if (e.key === 'F12' ||
        (e.ctrlKey && e.shiftKey && /[ijc]/i.test(e.key)) ||
        (e.ctrlKey && /[us]/i.test(e.key))) {
      e.preventDefault(); e.stopPropagation();
      return false;
    }
  }, { passive: false });


  // ---------- 2) MODAL CREATION & POLISH ----------
  function createModal() {
    const container = document.getElementById('section-modal') || document.createElement('div');
    container.id = 'section-modal';
    container.setAttribute('aria-hidden', 'true');

    // only add card if not existing
    let card = container.querySelector('.modal-card');
    if (!card) {
      card = document.createElement('div');
      card.className = 'modal-card';
      card.setAttribute('role', 'dialog');
      card.setAttribute('aria-modal', 'true');

      const closeBtn = document.createElement('button');
      closeBtn.className = 'close-btn';
      closeBtn.innerHTML = 'âœ•';
      closeBtn.addEventListener('click', close);
      card.appendChild(closeBtn);

      container.appendChild(card);
    }

    function open(node, titleText) {
      // clear previous content except close button
      const closeBtn = card.querySelector('.close-btn');
      Array.from(card.children).forEach(child => { if (child !== closeBtn) child.remove(); });

      const heading = document.createElement('h2');
      heading.className = 'modal-title';
      heading.textContent = titleText;
      card.appendChild(heading);

      const contentWrap = document.createElement('div');
      contentWrap.className = 'modal-content';
      contentWrap.style.maxHeight = 'calc(100vh - 140px)';
      contentWrap.style.overflow = 'auto';
      contentWrap.appendChild(node);
      card.appendChild(contentWrap);

      container.setAttribute('aria-hidden', 'false');
      document.body.style.overflow = 'hidden';
      // animated focus
      closeBtn.focus();
    }

    function close() {
      container.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
      const content = card.querySelector('.modal-content');
      if (content) content.remove();
      card.style.transform = '';
    }

    // keyboard & outside click
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && container.getAttribute('aria-hidden') === 'false') close(); });
    container.addEventListener('click', (e) => { if (e.target === container) close(); });

    // attach to DOM if new
    if (!document.getElementById('section-modal')) document.body.appendChild(container);
    return { container, open, close };
  }

  const modal = createModal();


  // ---------- 3) TITLES: WRAP + SMOOTH 3D TILT ----------
  const titles = Array.from(document.querySelectorAll('h1, h3'));
  const TILT = 7; // reduced tilt for refined look

  titles.forEach(title => {
    // wrap text in title-card if not already
    if (!title.querySelector('.title-card')) {
      const wrapper = document.createElement('span');
      wrapper.className = 'title-card';
      while (title.firstChild) wrapper.appendChild(title.firstChild);
      title.appendChild(wrapper);
    }

    // pointer & hover
    title.style.cursor = 'pointer';

    // mouse-based tilt (requestAnimationFrame throttled)
    let rect = null, raf = null;
    const onMove = (e) => {
      rect = rect || title.getBoundingClientRect();
      const px = (e.clientX - rect.left) / rect.width;
      const py = (e.clientY - rect.top) / rect.height;
      const rotY = (px - 0.5) * (TILT * 2);
      const rotX = (0.5 - py) * (TILT * 2);
      cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => {
        title.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg) translateZ(6px)`;
        title.style.boxShadow = `${-rotY/2}px ${rotX/2}px 22px rgba(0,0,0,0.35)`;
      });
    };
    const onLeave = () => {
      cancelAnimationFrame(raf);
      title.style.transform = '';
      title.style.boxShadow = '';
      rect = null;
    };

    title.addEventListener('mousemove', onMove);
    title.addEventListener('mouseleave', onLeave);

    // click opens modal with cloned section
    title.addEventListener('click', () => {
      let section = title.closest('section') || title.parentElement;
      const clone = section.cloneNode(true);
      // remove internal ids to avoid conflicts
      clone.querySelectorAll('[id]').forEach(el => el.removeAttribute('id'));
      modal.open(clone, (title.innerText || title.textContent).trim());
    });
  });


  // ---------- 4) LIGHTWEIGHT PARTICLES (REFINED) ----------
  const enhancerBg = document.getElementById('enhancer-bg');
  if (enhancerBg) {
    const canvas = document.createElement('canvas');
    canvas.id = 'enhancer-canvas';
    enhancerBg.appendChild(canvas);
    const ctx = canvas.getContext('2d');

    let particles = [];
    const COUNT = Math.min(Math.max(14, Math.floor((window.innerWidth * window.innerHeight) / 150000)), 36); // fewer particles for polished look
    let last = 0;

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(enhancerBg.clientWidth * dpr);
      canvas.height = Math.floor(enhancerBg.clientHeight * dpr);
      canvas.style.width = enhancerBg.clientWidth + 'px';
      canvas.style.height = enhancerBg.clientHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      initParticles();
    }

    function initParticles() {
      particles = [];
      for (let i = 0; i < COUNT; i++) {
        particles.push({
          x: Math.random() * enhancerBg.clientWidth,
          y: Math.random() * enhancerBg.clientHeight,
          vx: (Math.random() - 0.5) * 0.3,
          vy: (Math.random() - 0.5) * 0.3,
          r: 0.8 + Math.random() * 1.6,
          a: 0.03 + Math.random() * 0.06
        });
      }
    }

    function frame(t) {
      if (!last) last = t;
      const dt = Math.min(40, t - last);
      last = t;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.x += p.vx * (dt / 16);
        p.y += p.vy * (dt / 16);

        if (p.x < -10) p.x = enhancerBg.clientWidth + 10;
        if (p.x > enhancerBg.clientWidth + 10) p.x = -10;
        if (p.y < -10) p.y = enhancerBg.clientHeight + 10;
        if (p.y > enhancerBg.clientHeight + 10) p.y = -10;

        ctx.beginPath();
        ctx.fillStyle = `rgba(185,215,245,${p.a})`;
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();

        // subtle connecting lines
        for (let j = i + 1; j < particles.length; j++) {
          const q = particles[j];
          const dx = p.x - q.x;
          const dy = p.y - q.y;
          const d2 = dx * dx + dy * dy;
          if (d2 < 110 * 110) {
            const dist = Math.sqrt(d2);
            const alpha = (1 - dist / 110) * 0.06;
            ctx.beginPath();
            ctx.strokeStyle = `rgba(140,180,200,${alpha})`;
            ctx.lineWidth = 1;
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(q.x, q.y);
            ctx.stroke();
            ctx.closePath();
          }
        }
      }

      if (!document.hidden) requestAnimationFrame(frame);
      else last = 0;
    }

    resize();
    requestAnimationFrame(frame);
    let rt; window.addEventListener('resize', ()=>{ clearTimeout(rt); rt = setTimeout(resize, 220); });
  }

  // ---------- 5) SMALL PERFORMANCE & ACCESSIBILITY NOTES ----------
  // Titles and modal interactions respect reduced-motion preference via CSS transitions.
  // Right-click blocking is in place (deterrent), inputs are not blocked.

})();
